#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/cf40aff7-2072-48a6-8e32-af7c6d4c145a 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float bodyTemperature;
  int currentBpm;
  bool caduta;
  bool wearGlasses;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#include <Wire.h>
#include "MAX30105.h"
#include "heartRate.h"

#include <Arduino_LSM6DS3.h>

//dichiarazioni e variabili globali del sensore MAX30102
MAX30105 heartSensor;
const byte heatAvgArraySize = 10; //dimensione dell'array della media aritmetica dei battiti
byte heartAvgArraySize[heatAvgArraySize]; //array della media aritmetica dei battiti
byte indexArrayAvg = 0;
long exBeatsTime = 0;
long delta = 0; //variabile dove verrà salvato il tempo trascorso tra una battito e l'altro
float beatsPerMinute = 0;
float temperature;
int beatAvg = 0;

//dichiarazioni e variabili globali del sensore LSM6DS3
float ax = 0, ay = 0, az = 0, gx = 0, gy = 0, gz = 0;
boolean fall = false; //true se si è rilevata una caduta
boolean trigger1=false; //trigger per la soglia critica inferiore dell'accelerazione totale
boolean trigger2=false; //trigger per la soglia critica superiore dell'accelerazione totale
boolean trigger3=false; //trigger per la soglia critica superiore della velocità angolare
/*
i seguenti contatori servono ad impostare un tempo a partire dal quale ogni trigger attende all'incirca
500ms che si verifichi il trigger successivo
*/
byte trigger1count = 0; //conta i cicli in cui trigger1 = true
byte trigger2count = 0; //conta i cicli in cui trigger2 = true
byte trigger3count = 0; //conta i cicli in cui trigger3 = true
int omega = 0;
float acc = 0;

//altre dichiarazioni e variabili globali
const int buzzer = 9;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  pinMode(buzzer, OUTPUT);

//----------------------------Arduino cloud-----------------------------
  initProperties();
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
//----------------------------Arduino cloud-----------------------------

//-------------------------Sensore di battiti-----------------------------
    //Controllo hardare del MAX30102
    if (!heartSensor.begin(Wire, I2C_SPEED_FAST)) //porta fast di default per I2C, 400kHz
    {
        Serial.println("MAX30105 non trovato. Problema hardware. Blocco sistema");
        while (1);
    }
    Serial.println("Sensore MAX30102 correttamente riconosciuto");

    heartSensor.setup(); //metodo per configurare il sensore con i valori di default del produttore
    heartSensor.setPulseAmplitudeRed(0x0A); //accensione led rosso
    heartSensor.setPulseAmplitudeGreen(0); //spegnimento led verde
    heartSensor.enableDIETEMPRDY(); // att temperatura
//-------------------------Sensore di battiti-----------------------------

//------------------------------LSM6DS3-----------------------------------
    if (!IMU.begin()) 
    {
        Serial.println("Failed to initialize IMU!");
        while (1);
    }

    Serial.print("Gyroscope sample rate = ");
    Serial.print(IMU.gyroscopeSampleRate());
    Serial.println(" Hz");  
    Serial.println();
    Serial.println("Gyroscope in degrees/second");

    Serial.print("Accelerometer sample rate = ");
    Serial.print(IMU.accelerationSampleRate());
    Serial.println(" Hz");
    Serial.println();
    Serial.println("Acceleration in G's");
    Serial.println("X\tY\tZ");
//------------------------------LSM6DS3-----------------------------------
    wearGlasses = false;
    caduta = false;
    tone(buzzer, 523.25, 133);
    delay(133);
    tone(buzzer, 523.25, 133);
    delay(133);
    tone(buzzer, 523.25, 133);
    delay(133);
    tone(buzzer, 523.25, 400);
    delay(400);
    tone(buzzer, 415.30, 400);
    delay(400);
    tone(buzzer, 466.16, 400);
    delay(400);
    tone(buzzer, 523.25, 133);
    delay(133);
    delay(133);
    tone(buzzer, 466.16, 133);
    delay(133);
    tone(buzzer, 523.25, 1200);
    delay(1200);
}

void loop() {
  if(mytimer(10000))
    {
        if(wearGlasses)bodyTemperature = heartSensor.readTemperature() + 10.5;
        else bodyTemperature = 0;
        ArduinoCloud.update();
    }
  
  //-------------------------------FC DETECTION-----------------------------
  long irValue = heartSensor.getIR(); //valore ir direttamente dal Max30102

    if (irValue >= 50000)
    {
        wearGlasses = true;
        if (checkForBeat(irValue) == true)
        {
            //rilevato un battito riproduco un bip dal buzzer
            tone(buzzer, 3000);
            delay(10);
            noTone(buzzer);
            
            long tempTime = millis(); //salvo tempo corrente
            delta = tempTime - exBeatsTime; // tempo trascorso tra battito corrente e precedente
            exBeatsTime = tempTime;
        
            beatsPerMinute = 60 / (delta / 1000.0);
        
            if (beatsPerMinute < 255 && beatsPerMinute > 35)
            {
                heartAvgArraySize[indexArrayAvg++] = (byte)beatsPerMinute; //aggiungo la lettura nell'array
                indexArrayAvg %= heatAvgArraySize; //Wrap variable
                //media delle letture
                beatAvg = 0;
                for (byte x = 0 ; x < heatAvgArraySize ; x++)
                beatAvg += heartAvgArraySize[x];
                beatAvg /= heatAvgArraySize;
            }
        currentBpm = beatAvg;
        /*
        Serial.print("Body Temperature °C = ");
        Serial.print(temperature+1.4 , 4);
        Serial.print("IR=");
        Serial.print(irValue);
        Serial.print(", BPM=");
        Serial.print(beatsPerMinute);
        Serial.print(", Avg BPM=");
        Serial.println(beatAvg);
        */
        } 
    }else 
    {
        bodyTemperature = 0;
        currentBpm = 0;
        wearGlasses = false;
        //Serial.println("Occhiali non indossati!");
    }
//-------------------------------FC DETECTION-----------------------------
  
//------------------------------FALL DETECTION-----------------------------
    if(IMU.accelerationAvailable() && IMU.gyroscopeAvailable())
    {
        leggiLSM6DS3();
    }
    
    leggiLSM6DS3();
    acc = pow(pow(ax,2)+pow(ay,2)+pow(az,2),0.5);
    int accMod = acc * 10; //visto che i valori di equilibrio sono da 0 a 1
    //Serial.println(accMod);

    if (trigger3==true)
    {
        omega = pow(pow(gx,2)+pow(gy,2)+pow(gz,2),0.5);
        trigger3count++;
        //Serial.println(trigger3count);
        if (trigger3count>=10)
        { 
            omega = pow(pow(gx,2)+pow(gy,2)+pow(gz,2),0.5);
            //Serial.println(omega); 
            if ((omega>=0) && (omega<=10))
            { //ritorno a situazione di equilibrio quindi impatto
                fall=true; trigger3=false; trigger3count=0;
                //Serial.println(omega);
            }
            else
            { //probabilmente era un movimento 
                trigger3=false; trigger3count=0;
                Serial.println("TRIGGER 3 DEACTIVATED");
            }
        }
    }
    if (fall==true)
    { //se è stata rilevata una caduta faccio suonare il buzzer
        Serial.println("FALL DETECTED");
        tone(buzzer, 1000);
        caduta = true;
        ArduinoCloud.update();
        delay(2000);
        noTone(buzzer);
        fall=false;
        caduta = false;
        ArduinoCloud.update();
        // exit(1);
    }
    if (trigger2count>=6)
    { //nei prossimi 0.5 secondi si cercherà il superamento della soglia critica superiore di omega
        trigger2=false; trigger2count=0;
        Serial.println("TRIGGER 2 DECACTIVATED");
    }
    if (trigger1count>=6)
    { //nei prossimi 0.5 secondi si cercherà il superamento della soglia critica superiore di accMod
        trigger1=false; trigger1count=0;
        Serial.println("TRIGGER 1 DECACTIVATED");
    }
    if (trigger2==true)
    {
        trigger2count++;
        omega = pow(pow(gx,2)+pow(gy,2)+pow(gz,2),0.5); Serial.println(omega);
        if (omega>=61 && omega<=400)
        { //SOGLIA CRITICA SUPERIORE OMEGA
            trigger3=true; trigger2=false; trigger2count=0;
            Serial.println(omega);
            Serial.println("TRIGGER 3 ACTIVATED");
        }
    }
    if (trigger1==true)
    {
        trigger1count++;
        if (accMod>=12)
        { //SOGLIA CRITICA SUPERIORE ACCMOD
            trigger2=true;
            Serial.println("TRIGGER 2 ACTIVATED");
            Serial.println(accMod);
            trigger1=false; trigger1count=0;
        }
    }
    if (accMod<=2 && trigger2==false)
    { //SOGLIA CRITICA INFERIORE ACCMOD
        trigger1=true;
        Serial.println("TRIGGER 1 ACTIVATED");
        Serial.println(accMod);
    }
//------------------------------FALL DETECTION-----------------------------  
}


int mytimer(int timerdurata){
  static unsigned long t1, dt;
  int ret = 0;
  dt = millis() -t1;
  if (dt >= timerdurata){
    t1 = millis();
    ret = 1;
    }
  return ret;
}

void leggiLSM6DS3(){
 IMU.readGyroscope(gx, gy, gz);
 IMU.readAcceleration(ax, ay, az);
}

/*
  Since BodyTemperature is READ_WRITE variable, onBodyTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBodyTemperatureChange()  {
  // Add your code here to act upon BodyTemperature change
}
/*
  Since CurrentBpm is READ_WRITE variable, onCurrentBpmChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCurrentBpmChange()  {
  // Add your code here to act upon CurrentBpm change
}
/*
  Since Caduta is READ_WRITE variable, onCadutaChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCadutaChange()  {
  // Add your code here to act upon Caduta change
}
/*
  Since WearGlasses is READ_WRITE variable, onWearGlassesChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWearGlassesChange()  {
  // Add your code here to act upon WearGlasses change
}